use import("util.tiny")

data := read_file("inputs/day16.txt")

lines := data->split_by_char('\n')
lines->astr_pop()

EMPTY :: 0
WALL  :: 1

struct V2 {
    x: int
    y: int
}

func v2_add(a: V2, b: V2): V2 {
    return new V2{a.x + b.x, a.y + b.y}
}

func v2_sub(a: V2, b: V2): V2 {
    return new V2{a.x - b.x, a.y - b.y}
}

struct World {
    w: int
    h: int
    rows: aint
    pos: V2
    end_pos: V2
}

func get_tile(w: World, x: int, y: int): int {
    if x < 0 || x >= w.w {
        return -1
    }

    if y < 0 || y >= w.h {
        return -1
    }

    return w.rows[x + y * w.w]
}

func parse_world(lines: astr): World {
    w := lines[0]->strlen()
    h := lines->astr_len()

    rows := aint()
    rows->aint_resize_fill(w * h, EMPTY)

    pos := new V2{-1, -1}
    end_pos := new V2{-1, -1}

    foreach line, y in lines {
        foreach ch, x in line {
            if ch == '#' {
                rows[x+y*w] = WALL
            } else if ch == 'S' {
                pos.x = x
                pos.y = y
            } else if ch == 'E' {
                end_pos.x = x
                end_pos.y = y 
            }
        }
    }

    return new World{
        .w = w,
        .h = h,
        .rows = rows,
        .pos = pos,
        .end_pos = end_pos,
    }
}

RIGHT :: 0
DOWN :: 1
LEFT :: 2
UP :: 3
DIR_COUNT :: 4

func delta_x(dir: int): int {
    if dir == RIGHT return 1
    else if dir == LEFT return -1
    else return 0
}

func delta_y(dir: int): int {
    if dir == DOWN return 1
    else if dir == UP return -1
    else return 0
}

func store_scores(w: World, x: int, y: int, dir: int, score: int, pmin: aint) {
    if w->get_tile(x, y) != EMPTY {
        // Not a valid path here
        return;
    }
    

    v := pmin[x + y * w.w]
    if v >= 0 && v < score {
        // This is the shortest path so far since we started at the end, don't overwrite it
        return;
    }

    // printf("at %q %q, dir = %q score = %q\n", x, y, dir, score)

    // We must only store min scores for the end pos if we're facing left (opposite of right)
    done := false

    if x == w.end_pos.x && y == w.end_pos.y {
        if dir == DOWN {
            // Need to turn to face right
            score += 1000
        } else if dir == UP {
            score += 1000
        } else if dir == RIGHT {
            score += 2000
        }

        done = true
    }

    pmin[x + y * w.w] = score

    if done {
        return;
    }
 
    d0 := dir
    d1 := (dir + 1) % DIR_COUNT
    d2 := (dir + 2) % DIR_COUNT
    d3 := (dir + 3) % DIR_COUNT

    store_scores(w, x + delta_x(d0), y + delta_y(d0), d0, score + 1, pmin)
    store_scores(w, x + delta_x(d1), y + delta_y(d1), d1, score + 1001, pmin)
    store_scores(w, x + delta_x(d2), y + delta_y(d2), d2, score + 2001, pmin)
    // Only 1000 because we can turn counterclockwise
    store_scores(w, x + delta_x(d3), y + delta_y(d3), d3, score + 1001, pmin)
}

func pm_get(pmin: aint, w: World, x: int, y: int): int {
    if x < 0 || x >= w.w ||
       y < 0 || y >= w.h {
        return -1
    }

    return pmin[x + y * w.w]
}

func mark_best(w: World, x: int, y: int, pmin: aint, marked: abool, prev_val: int) {
    if w->get_tile(x, y) != EMPTY {
        return;
    }

    marked[x + y * w.w] = true
    // printf("marking %q %q (score: %q, prev %q)\n", x, y, pmin[x + y * w.w], prev_val)

    d0 := pmin->pm_get(w, x + 1, y)
    d1 := pmin->pm_get(w, x, y + 1)
    d2 := pmin->pm_get(w, x - 1, y)
    d3 := pmin->pm_get(w, x, y - 1)

    // printf("d0=%q d1=%q d2=%q d3=%q\n", d0, d1, d2, d3)
    
    best := INT_MAX

    if d0 >= 0 && d0 < prev_val && d0 < best {
        best = d0
    }

    if d1 >= 0 && d1 < prev_val && d1 < best {
        best = d1
    }

    if d2 >= 0 && d2 < prev_val && d2 < best {
        best = d2
    }

    if d3 >= 0 && d3 < prev_val && d3 < best {
        best = d3
    }

    if d0 == best {
        mark_best(w, x + 1, y, pmin, marked, best)
    }

    if d1 == best {
        mark_best(w, x, y + 1, pmin, marked, best)
    }

    if d2 == best {
        mark_best(w, x - 1, y, pmin, marked, best)
    }
    
    if d3 == best {
        mark_best(w, x, y - 1, pmin, marked, best)
    }
}

w := parse_world(lines)
// printf("%q\n", w)

// Swap pos and end pos so we can work backwards
epos := w.end_pos
spos := w.pos

printf("spos=%q epos=%q\n", spos, epos)

w.end_pos = spos
w.pos = epos

pmin := aint()
pmin->aint_resize_fill(w.w * w.h, -1)

// Approach from all dirs (order matters here???)
store_scores(w, w.pos.x, w.pos.y, LEFT, 0, pmin)
store_scores(w, w.pos.x, w.pos.y, DOWN, 0, pmin)
store_scores(w, w.pos.x, w.pos.y, UP, 0, pmin)
store_scores(w, w.pos.x, w.pos.y, DOWN, 0, pmin)

printf("score=%q\n", pmin[spos.x + spos.y * w.w])

// print_aint_grid_w(pmin, w.w, w.h, 8)

marked := abool()
marked->abool_resize_fill(w.w * w.h, false)

mark_best(w, spos.x, spos.y, pmin, marked, pmin[spos.x + spos.y * w.w])

// print_abool_grid(marked, w.w, w.h)

mark_count := 0

for y := 0; y < w.h; y += 1 {
    for x := 0; x < w.w; x += 1 {
        if marked[x + y * w.w] {
            mark_count += 1
        }
    }
}

printf("%q\n", mark_count)
