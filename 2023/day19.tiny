input_contents := read_file("inputs/day19_ex.txt")

func split_by_char(input: str, ch: int): array {
    // Necessary because mutating arguments doesn't work haha
    s := input
    parts := array()

    while true {
        end_of_part_pos := strchr(s, ch)
        part := substr(s, 0, end_of_part_pos)

        array_push(parts, part)

        if end_of_part_pos == -1 {
            break
        }
        
        s = substr(s, end_of_part_pos + 1, -1)
    }

    return parts
}

struct Rule {
    cat: int
    op: int
    value: int
    target: str
}

struct Workflow {
    name: str
    predicate_rules: array
    default_target: str
}

// Example workflow: `px{a<2006:qkq,m>2090:A,rfg}`
func parse_workflow(line: str): Workflow {
    rules_start_pos := strchr(line, '{')
    rules_end_pos := strchr(line, '}')

    name := substr(line, 0, rules_start_pos)
    rules_str := substr(line, rules_start_pos + 1, rules_end_pos)
    
    rules_strs := split_by_char(rules_str, ',')

    predicate_rules := array()
    default_target := ""

    for i := 0; i < array_len(rules_strs); i += 1 {
        rule_str: str = array_get(rules_strs, i)

        // Predicate rules have a colon
        colon_pos := strchr(rule_str, ':')

        if colon_pos == -1 {
            default_target = rule_str
            continue
        }

        rule_parts := split_by_char(rule_str, ':')

        predicate_str: str = array_get(rule_parts, 0) 

        cat := stridx(predicate_str, 0)
        op := stridx(predicate_str, 1)
        value := stoi(substr(predicate_str, 2, -1), 10)
        target: str = array_get(rule_parts, 1)

        array_push(predicate_rules, new Rule{cat, op, value, target})
    }

    return new Workflow{name, predicate_rules, default_target}
}

func print_workflow(workflow: Workflow) {
    printf("%s{", workflow.name)

    for i := 0; i < array_len(workflow.predicate_rules); i += 1 {
        rule: Rule = array_get(workflow.predicate_rules, i)

        printf("%c%c%i:%s", rule.cat, rule.op, rule.value, rule.target)
    }
    
    printf(",%s}\n", workflow.default_target)
}

struct CatValue {
    cat: int
    value: int
}

struct Part {
    cat_values: array
}

// Part example: {x=787,m=2655,a=1222,s=2876}
func parse_part(line: str): Part {
    sub := substr(line, 1, strlen(line) - 1)

    cat_strs := split_by_char(sub, ',')

    cat_values := array()

    for i := 0; i < array_len(cat_strs); i += 1 {
        cat_value_str: str = array_get(cat_strs, i)

        cat := stridx(cat_value_str, 0)
        value := stoi(substr(cat_value_str, 2, -1), 10)

        array_push(cat_values, new CatValue{cat, value})    
    }

    return new Part{cat_values}
}

func print_part(part: Part) {
    printf("{")
    
    first := true

    for i := 0; i < array_len(part.cat_values); i += 1 {
        if !first {
            printf(",")
        }

        first = false

        cat_value: CatValue = array_get(part.cat_values, i)

        printf("%c=%i", cat_value.cat, cat_value.value)
    }

    printf("}\n")
}

lines := split_by_char(input_contents, '\n')

for i := 0; i < array_len(lines); i += 1 {
    line: str = array_get(lines, i)

    if strlen(line) == 0 {
        continue
    }

    if stridx(line, 0) == '{' { 
        part := parse_part(line)
        print_part(part) 
    } else {
        workflow := parse_workflow(line)
        print_workflow(workflow)
    }
}